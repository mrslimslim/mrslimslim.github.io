(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{462:function(e,t,a){"use strict";a.r(t);var v=a(44),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"webpack-模块联邦"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-模块联邦"}},[e._v("#")]),e._v(" Webpack 模块联邦")]),e._v(" "),a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" 背景")]),e._v(" "),a("p",[e._v("多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。")]),e._v(" "),a("p",[e._v("这通常被称作"),a("em",[e._v("微前端")]),e._v("，但并不仅限于此。")]),e._v(" "),a("h2",{attrs:{id:"术语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[e._v("#")]),e._v(" 术语")]),e._v(" "),a("ol",[a("li",[e._v("本地模块")]),e._v(" "),a("li",[e._v("远程模块")]),e._v(" "),a("li",[e._v("构建即容器")]),e._v(" "),a("li",[e._v("共享模块")])]),e._v(" "),a("h2",{attrs:{id:"相关插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关插件"}},[e._v("#")]),e._v(" 相关插件")]),e._v(" "),a("p",[a("em",[e._v("ContainerPlugin")]),e._v(" : 该插件使用指定的公开模块来创建一个额外的容器入口。")]),e._v(" "),a("p",[a("em",[e._v("ContainerReferencePlugin")]),e._v(" :")]),e._v(" "),a("p",[a("em",[e._v("ModuleFederationPlugin")]),e._v(" : ModuleFederationPlugin包含ContainerPlugin和ContainerReferencePlugin")]),e._v(" "),a("h2",{attrs:{id:"使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[e._v("#")]),e._v(" 使用场景")]),e._v(" "),a("ol",[a("li",[e._v("将大型应用拆分")]),e._v(" "),a("li",[e._v("将组件库作为(父应用)容器。每个应用程序使用来自组件容器的组件。可以单独部署组件库的更改，，而不需要部署所有应用程序，可以作为团队公共的宿主运行环境。应用程序自动使用组件库的最新版。")]),e._v(" "),a("li",[e._v("动态远程容器。该容器支持"),a("em",[e._v("get")]),e._v("和"),a("em",[e._v("init")]),e._v("方法。init是一个兼容"),a("em",[e._v("async")]),e._v("的方法，调用时，只含")])])])}),[],!1,null,null,null);t.default=_.exports}}]);