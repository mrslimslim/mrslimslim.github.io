(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{483:function(s,e,t){"use strict";t.r(e);var n=t(56),r=Object(n.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"webpack按需加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack按需加载"}},[s._v("#")]),s._v(" Webpack按需加载")]),s._v(" "),t("h2",{attrs:{id:"按需加载原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按需加载原理"}},[s._v("#")]),s._v(" 按需加载原理")]),s._v(" "),t("p",[s._v("它的处理逻辑如下：")]),s._v(" "),t("p",[t("strong",[s._v("判断是否已加载")]),s._v("。先查看该模块 ID 对应缓存的值是否为 0，0 代表已经加载成功了，第一次取值为 undefined。\n"),t("strong",[s._v("判断在加载中，加入Promise队列")]),s._v("。如果不为 0 并且不是 undefined 代表已经是加载中的状态。然后将这个加载中的 Promise 推入 promises 数组。\n"),t("strong",[s._v("判断未加载")]),s._v("如果不为 0 并且是 undefined 就新建一个 Promise，用于加载需要动态导入的模块。\n"),t("strong",[s._v("生成script标签，动态导入url")]),s._v("生成一个 script 标签，URL 使用 jsonpScriptSrc(chunkId) 生成，即需要动态导入模块的 URL。\n为这个 script 标签设置一个 2 分钟的超时时间，并设置一个 onScriptComplete() 函数，用于处理超时错误。\n"),t("strong",[s._v("通过document.head.appendChild(script)，加载模块")]),s._v("然后添加到页面中 document.head.appendChild(script)，开始加载模块。\n返回 promises 数组。")]),s._v(" "),t("p",[s._v('当 JS 文件下载完成后，会自动执行文件内容。也就是说下载完 0.bundle.js 后，会执行 window["webpackJsonp"].push()。')]),s._v(" "),t("p",[s._v("按需加载流程图\n"),t("img",{attrs:{src:"https://blog-1253253332.cos.ap-guangzhou.myqcloud.com/images/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.png",alt:""}})]),s._v(" "),t("p",[s._v("1、怎么保证相同的文件只加载一次？\n答：installedChunks[chunkId]是否为0。定义installedChunks对象，存储异步js的promise回调，如果已经加载过，则返回一个空数组的promise.all([])，如果在加载过程中，则返回已经存储过的此文件对应的promise。\n2、怎么判断文件加载完成？\n答：有一个resolve回调")]),s._v(" "),t("h2",{attrs:{id:"如何使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何使用"}},[s._v("#")]),s._v(" 如何使用")]),s._v(" "),t("ol",[t("li",[s._v("require.ensure")]),s._v(" "),t("li",[s._v("import().then()")]),s._v(" "),t("li",[s._v("react方案React.lazy, suspense等")])])])}),[],!1,null,null,null);e.default=r.exports}}]);